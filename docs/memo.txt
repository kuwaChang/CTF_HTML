HTTPリクエストとレスポンスの知識
    HTTPではクライアントが出したリクエストをサーバー側で処理し、レスポンスとして返す。
    クライアントが行うこと
        リクエストメッセージの構築、送信
        レスポンスが返ってくるまで待機
        レスポンスメッセージの受信、解析
        クライアントの目的を達成するまでに必要な処理
    
    サーバが行うこと
        リクエストの待機
        リクエストメッセージの受信、解析
        適切なアプリケーションプログラムへの処理の委譲
        アプリケーションプログラムから結果を取得
        レスポンスメッセージの構築、送信
    
    リクエストメッセージについて
        リクエストラインについて
            リクエストメッセージの1行目のことをいう
            メソッド：GET、リクエスト：URI、プロトコルバージョン：HTTP/から成る
            URIフラグメントはクライアント側で処理するため、リクエストメッセージには含めない
            ポート番号はHostヘッダで指定する
        ヘッダについて
            リクエストメッセージの2行目以降のことをいう
            メッセージのメタデータ（データの特性や構造、利用方法に関する情報）である
            複数のヘッダが可能
            「名前：値」「Host：example.jp」
        ボディについて
            ヘッダの後に続くことがある
            メッセージを表す本質的な情報が入る
    
    レスポンスメッセージについて
        ステータスラインについて
            レスポンスメッセージの一行目のことをいう
            プロトコルバージョン：HTTP/1.1、ステータスコード：200、テキストフレーズ：OKから成る
            ステータスコードはリクエストの結果をプログラムが処理可能な数値コードで表す
        ヘッダについて
            レスポンスメッセージの2行目以降のことをいう
            Content-TypeヘッダでHTMLのMIMEメディアタイプ(application/xhtmk+xml)とその文字のエンコーディング方式(utf-8)を指定したりする
        ボディについて
            ヘッダとボディは空行(ヘッダ最終行末尾のCRLFに連続するCRLF)で区切られる
                LF･･･UNIX系（Linuxなど）
                CR･･･MacOS（バージョン9まで）など
                CR+LF･･･Microsoft Windows等

Webセキュリティの知識
    XSS（Cross-Site Scripting）について
        反射型XSS（Reflected XSS）
            悪意のあるスクリプトがURLパラメータなどに含まれ、サーバーからそのまま返される
            ユーザーがそのURLを開くと、スクリプトが実行される
            対策：入力値のサニタイゼーション、出力時のエスケープ処理
        格納型XSS（Stored XSS）
            悪意のあるスクリプトがデータベースなどに保存され、他のユーザーが閲覧した際に実行される
            対策：データベース保存前のサニタイゼーション、出力時のエスケープ処理
        DOM-based XSS
            クライアント側のJavaScriptでDOMを操作する際に発生
            innerHTMLの使用は危険（textContentやcreateElementを使用）
            対策：信頼できないデータをDOMに直接挿入しない
    
    SQLインジェクションについて
        脆弱な実装
            ユーザー入力を直接SQLクエリに埋め込むと発生
            例：`SELECT * FROM users WHERE username = '${username}'`
            攻撃例：`username = "admin' OR '1'='1"`
        対策
            パラメータ化クエリ（プリペアドステートメント）を使用
            例：`db.get("SELECT * FROM users WHERE username = ?", [username])`
            入力値の検証とサニタイゼーション
    
    CSRF（Cross-Site Request Forgery）について
        攻撃者がユーザーに意図しないリクエストを送信させる
        対策
            CSRFトークンの使用
            SameSiteクッキー属性の設定
            Refererヘッダの検証
    
    認証・認可について
        認証（Authentication）
            ユーザーが本人であることを確認する
            パスワードのハッシュ化（bcryptなど）が重要
        認可（Authorization）
            認証済みユーザーが特定のリソースにアクセスできるかを確認
            ロールベースアクセス制御（RBAC）が一般的
        セッション管理
            セッションIDの安全な生成と管理
            httpOnly属性でJavaScriptからのアクセスを防止
            secure属性でHTTPS経由のみ送信
    
    ファイルアップロードのセキュリティ
        ファイルタイプの検証
            MIMEタイプとファイル拡張子の両方をチェック
        ファイル名のサニタイゼーション
            パストラバーサル攻撃を防ぐ
            例：`../` などの文字列を除去
        ファイルサイズの制限
        アップロード先ディレクトリの権限設定

暗号（Cryptography）の知識
    Base64エンコーディングについて
        バイナリデータをテキスト形式で表現する方法
        64文字（A-Z, a-z, 0-9, +, /）を使用
        パディングに`=`を使用（末尾に1-2個）
        例：`cHZrcXsybWJpemR5fQ==`
        デコードツールやコマンド：`echo "文字列" | base64 -d`
    
    ROT13について
        シーザー暗号の一種で、アルファベットを13文字ずらす
        A→N, B→O, ..., M→Z, N→A
        例：`SYNT{ebg13}` → `FLAG{rot13}`
        特徴：ROT13を2回適用すると元に戻る（自己逆変換）
    
    モールス信号について
        点（・）と棒（－）で文字を表現
        例：`... --- ...` → `SOS`
        数字も対応しているサイトを使用する必要がある場合がある
        区切り：文字間は空白、単語間は`/`や長い空白
    
    バイナリ・16進数について
        バイナリ（2進数）
            0と1で表現
            例：`01001000 01100101 01101100 01101100 01101111` → `Hello`
        16進数（Hexadecimal）
            0-9とA-Fで表現
            例：`48656C6C6F` → `Hello`
        変換ツール：オンラインツールやコマンドライン（xxd, hexdump）
    
    ハッシュ関数について
        一方向関数で、元のデータから固定長のハッシュ値を生成
        代表的なアルゴリズム
            MD5：128ビット（32文字の16進数）、脆弱性あり
            SHA-1：160ビット、脆弱性あり
            SHA-256：256ビット、現在推奨
        用途：パスワード保存、データ整合性チェック、デジタル署名

OSINT（Open Source Intelligence）の知識
    公開情報収集について
        ソーシャルメディアの調査
            Twitter、Facebook、LinkedInなどの公開プロフィール
            EXIFデータ（位置情報、撮影日時など）
        画像検索
            Google画像検索、TinEyeなどのリバース画像検索
            EXIFデータの抽出（exiftoolなど）
        特許情報
            Google Patents、J-PlatPat（日本）
            出願日、出願人、特許番号などで検索
        座標情報の調査
            緯度・経度から場所を特定（Google Maps、OpenStreetMap）
            その場所に関連する事件や災害を調査
        メタデータの活用
            PDF、画像、ドキュメントファイルに含まれる情報
            作成日時、作成者、ソフトウェア情報など

フォレンジック（Forensics）の知識
    ファイル形式について
        ファイル拡張子と実際の形式が異なる場合がある
            例：`.bin`ファイルが実際はテキストや画像の場合
        ファイルシグネチャ（マジックナンバー）で判定
            例：PNGは`89 50 4E 47`、ZIPは`50 4B 03 04`
        ツール：`file`コマンド、`hexdump`、`xxd`
    
    メタデータについて
        EXIFデータ（画像）
            撮影日時、位置情報、カメラ情報など
            ツール：exiftool、オンラインツール
        PDFメタデータ
            作成者、作成日時、ソフトウェア情報
            ツール：pdfinfo、exiftool
        Office文書（Word、PowerPoint、Excel）
            作成者、最終更新日時、コメントなど
            PowerPoint（.pptx）はZIP形式でもある
    
    ステガノグラフィについて
        データを別のデータに隠す技術
        画像への埋め込み
            LSB（Least Significant Bit）ステガノグラフィ
            ツール：steghide、stegsolve
        テキストファイルへの埋め込み
            空白文字や改行を利用した手法
    
    アーカイブファイルについて
        ZIPファイル
            パスワード保護されている場合がある
            ツール：zip2john、john the ripper
        TAR、GZIP、BZIP2などの圧縮形式
    
    バイナリ解析について
        ファイルの16進数ダンプを確認
        文字列の抽出：`strings`コマンド
        実行可能ファイルの解析：objdump、readelf、IDA、Ghidra

ネットワークプロトコルの知識
    HTTPメソッドについて
        GET：リソースの取得
        POST：リソースの作成・送信
        PUT：リソースの更新
        DELETE：リソースの削除
        HEAD：ヘッダ情報のみ取得
        OPTIONS：サーバーがサポートするメソッドを確認
    
    HTTPステータスコードについて
        2xx：成功
            200 OK：リクエスト成功
            201 Created：リソース作成成功
        3xx：リダイレクト
            301 Moved Permanently：恒久的な移動
            302 Found：一時的な移動
        4xx：クライアントエラー
            400 Bad Request：不正なリクエスト
            401 Unauthorized：認証が必要
            403 Forbidden：アクセス拒否
            404 Not Found：リソースが見つからない
        5xx：サーバーエラー
            500 Internal Server Error：サーバー内部エラー
            502 Bad Gateway：ゲートウェイエラー
    
    HTTPヘッダについて
        リクエストヘッダ
            User-Agent：クライアントの情報
            Referer：参照元URL
            Cookie：セッション情報
            Authorization：認証情報
        レスポンスヘッダ
            Set-Cookie：クッキーの設定
            Content-Type：コンテンツの種類
            Content-Length：コンテンツのサイズ
            Location：リダイレクト先

エンコーディング・デコーディングの知識
    文字エンコーディングについて
        UTF-8：Unicodeの可変長エンコーディング、現在の標準
        ASCII：7ビット、128文字
        Shift_JIS：日本語の文字コード
        URLエンコーディング（パーセントエンコーディング）
            例：`%20`は空白、`%2F`は`/`
    
    エンコーディングの種類
        Base64：バイナリ→テキスト
        Hex（16進数）：バイナリ→16進数文字列
        Binary（2進数）：バイナリ→0と1の文字列
        URLエンコーディング：特殊文字を%XX形式に変換
    
    デコードツール
        オンラインツール：CyberChef、dCode
        コマンドライン：base64、xxd、od、python

CTF問題を解く際の基本的なアプローチ
    問題文の読み方
        問題文に含まれるキーワードを抽出
        カテゴリー（crypto、web、forensics、osintなど）を特定
        提供されたファイルやURLを確認
    
    フラグの形式
        通常は`FLAG{...}`形式
        座標形式の場合もある（例：`FLAG{緯度,経度}`）
        日付形式の場合もある（例：`FLAG{年/月/日}`）
    
    ツールの活用
        ブラウザの開発者ツール（F12）
        ネットワークタブでHTTPリクエスト/レスポンスを確認
        コンソールでJavaScriptを実行
        コマンドライン：curl、wget、nc（netcat）
        ファイル解析：file、strings、hexdump、exiftool
    
    ヒントの活用
        問題にヒントが含まれている場合がある
        ヒントから解法の方向性を推測
        複数のヒントがある場合は順番に確認
            
今後の展開
    1. AI チューターモード
        問題で詰まった際にAIがヒントを生成
        解答後の解説を自動生成
        学習パターンに基づく問題推薦
    2. 協力プレイ機能
        チームチャット（問題ごと）
        共同編集可能なメモ
        チーム内での進捗共有
    3. 段階的学習パス
        前提知識を満たすと次の問題が解放
        スキルツリー表示
        カテゴリー別の習熟度可視化
    4. リアルタイム競技モード
        制限時間付きチャレンジ
        ライブランキング
        問題の動的難易度調整
    5. インタラクティブなデバッグ環境
        ブラウザ内デバッガー統合
        コード実行履歴の可視化
        ステップ実行機能
    6. メンター/レビュー機能
        解答後のコードレビュー
        メンターからのフィードバック
        ベストプラクティスの共有
    7. ゲーミフィケーション強化
        //アチーブメント/バッジ
        レベルシステム
        //カスタマイズ可能なアバター
    8. 多言語対応の学習コンテンツ
        日本語・英語の切り替え
        多言語での解説
        文化的コンテキストの考慮
    9. モバイル最適化
        モバイル端末での問題閲覧・解答
        タッチ操作に最適化されたUI
        オフライン学習モード
    10. 分析・レポート機能
        詳細な学習分析ダッシュボード
        弱点分野の可視化
        学習効率の測定
    推奨実装順序
        段階的学習パス - 既存のカテゴリー機能と相性が良い
        ゲーミフィケーション強化 - 既存のスコアリングと連携
        AI チューターモード - 既存のヒント機能を拡張
        協力プレイ機能 - 既存のSocket.ioを活用